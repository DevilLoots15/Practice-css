<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Aviator — Front-end Demo</title>
  <style>
    :root{--bg:#0b1220;--card:#0f1724;--accent:#ffb556;--muted:#99a0b3;--glass:rgba(255,255,255,0.03)}
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,ui-sans-serif,system-ui,Roboto,'Helvetica Neue',Arial;color:#e6eef8;background:linear-gradient(180deg,#061028 0%, #081426 60%);min-height:100vh;display:flex;align-items:center;justify-content:center;padding:24px}
    .wrap{width:100%;max-width:1000px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:18px;display:grid;grid-template-columns:330px 1fr;gap:18px;box-shadow:0 10px 30px rgba(3,6,12,0.6)}
    .panel{background:var(--card);border-radius:10px;padding:16px}
    h1{font-size:18px;margin:0 0 12px}.balance{font-size:20px;font-weight:600;color:var(--accent);margin-bottom:12px}
label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
input[type=number],input[type=text]{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:var(--glass);color:#e9f3ff}
.btn{display:inline-block;padding:10px 12px;border-radius:8px;background:linear-gradient(90deg,#ffb556,#ff8b5b);color:#052028;font-weight:700;border:none;cursor:pointer}
.btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--accent)}

.controls{display:flex;gap:8px;margin-top:12px}
.game-area{padding:18px;display:flex;flex-direction:column;gap:14px}
.mult{font-size:56px;font-weight:800;color:#fff;text-shadow:0 8px 30px rgba(255,181,86,0.15);}
.ticker{height:8px;background:rgba(255,255,255,0.03);border-radius:999px;overflow:hidden}
.progress{height:100%;width:0%;background:linear-gradient(90deg,rgba(255,181,86,0.2),rgba(255,140,90,0.5));transition:width 0.1s linear}

.history{max-height:220px;overflow:auto;margin-top:8px;border-radius:8px;padding:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02))}
.hist-item{display:flex;justify-content:space-between;padding:8px;border-radius:6px;margin-bottom:8px;background:rgba(255,255,255,0.015)}
.muted{color:var(--muted)}

.right-top{display:flex;align-items:center;justify-content:space-between}
.small{font-size:13px;color:var(--muted)}

/* responsive */
@media (max-width:880px){.wrap{grid-template-columns:1fr;}}

  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <h1>Aviator — Demo (Front-end only)</h1>
      <div class="balance">Balance: <span id="balanceDisplay">1000</span> coins</div><label for="bet">Bet amount</label>
  <input id="bet" type="number" min="1" value="50" />

  <label for="auto">Auto cashout (multiplier, optional)</label>
  <input id="auto" type="number" step="0.01" min="1" placeholder="e.g. 2.5" />

  <div class="controls">
    <button id="placeBtn" class="btn">Place Bet</button>
    <button id="startBtn" class="btn ghost">Start Round</button>
    <button id="cashBtn" class="btn ghost" disabled>Cash Out</button>
  </div>

  <div style="margin-top:12px">
    <div class="small">Round status: <span id="status">Idle</span></div>
  </div>

  <div style="margin-top:12px">
    <label>History</label>
    <div class="history" id="history"></div>
  </div>

  <div style="margin-top:12px" class="small muted">This is a front-end demo only — no real money or server validation. Deploy to Vercel by placing this file in a static project.</div>
</div>

<div class="panel game-area">
  <div class="right-top">
    <div>
      <div class="small">Multiplier</div>
      <div class="mult" id="mult">1.00×</div>
    </div>
    <div style="text-align:right">
      <div class="small">Bet</div>
      <div style="font-weight:700;color:#fff" id="betSummary">—</div>
    </div>
  </div>

  <div class="ticker"><div class="progress" id="progress"></div></div>

  <canvas id="chart" width="700" height="260" style="background:transparent;border-radius:8px"></canvas>

  <div style="display:flex;gap:12px;align-items:center">
    <button id="demoAutoBtn" class="btn ghost">Demo Auto 2×</button>
    <div class="muted">Tip: place bet before starting the round. Cash out before crash to win.</div>
  </div>
</div>

  </div>  <script>
    // Simple front-end-only aviator (crash) demo
    const balanceEl = document.getElementById('balanceDisplay');
    const betInput = document.getElementById('bet');
    const autoInput = document.getElementById('auto');
    const placeBtn = document.getElementById('placeBtn');
    const startBtn = document.getElementById('startBtn');
    const cashBtn = document.getElementById('cashBtn');
    const statusEl = document.getElementById('status');
    const multEl = document.getElementById('mult');
    const progressEl = document.getElementById('progress');
    const betSummary = document.getElementById('betSummary');
    const historyEl = document.getElementById('history');
    const demoAutoBtn = document.getElementById('demoAutoBtn');

    const canvas = document.getElementById('chart');
    const ctx = canvas.getContext('2d');

    let balance = 1000;
    let placedBet = null; // {amount}
    let roundActive = false;
    let multiplier = 1;
    let crashPoint = null;
    let tickInterval = null;
    let history = [];

    function renderBalance(){balanceEl.textContent = balance.toFixed(2)}
    renderBalance();

    function addHistory(item){
      history.unshift(item);
      if(history.length>30) history.pop();
      historyEl.innerHTML = history.map(h=>`<div class="hist-item"><div><div style="font-weight:700">${h.result}</div><div class="muted">${h.details}</div></div><div style="text-align:right"><div style="font-weight:700">${h.mult.toFixed(2)}×</div><div class="muted">${h.time}</div></div></div>`).join('')
    }

    placeBtn.addEventListener('click',()=>{
      const val = Number(betInput.value);
      if(!val || val<=0) return alert('Enter a valid bet');
      if(val>balance) return alert('Not enough balance');
      placedBet = {amount: val};
      betSummary.textContent = val + ' coins';
      statusEl.textContent = 'Bet placed';
    })

    startBtn.addEventListener('click',()=>{
      if(roundActive) return;
      // start a new round — in real prod server decides crash point
      roundActive = true;
      multiplier = 1;
      crashPoint = generateCrashPoint();
      tickStart();
      statusEl.textContent = 'Running';
      cashBtn.disabled = !placedBet;
      startBtn.disabled = true;
      placeBtn.disabled = true;
      demoAutoBtn.disabled = true;
      drawChartClear();
    })

    cashBtn.addEventListener('click',()=>{
      if(!roundActive || !placedBet) return;
      // cash out at current multiplier
      const win = placedBet.amount * multiplier;
      balance += win;
      addHistory({result:'CASHED OUT', details:`WON ${win.toFixed(2)} coins`, mult:multiplier, time: new Date().toLocaleTimeString()});
      endRound(true);
    })

    demoAutoBtn.addEventListener('click',()=>{
      betInput.value = 10;
      autoInput.value = 2;
      placeBtn.click();
      startBtn.click();
    })

    function endRound(cashedOut=false){
      clearInterval(tickInterval);
      roundActive = false;
      startBtn.disabled = false;
      placeBtn.disabled = false;
      cashBtn.disabled = true;
      demoAutoBtn.disabled = false;
      if(!cashedOut){
        // lost bet
        if(placedBet){
          addHistory({result:'CRASHED', details:`LOST ${placedBet.amount.toFixed(2)} coins`, mult:crashPoint, time: new Date().toLocaleTimeString()});
        }
      }
      placedBet = null;
      betSummary.textContent = '—';
      statusEl.textContent = 'Idle';
      multiplier = 1;
      multEl.textContent = '1.00×';
      progressEl.style.width = '0%';
      drawChartClear();
    }

    function tickStart(){
      // take bet (front-end only)
      if(placedBet){
        balance -= placedBet.amount;
      }
      renderBalance();

      const autoVal = Number(autoInput.value) || 0;

      const start = Date.now();
      const duration = 5000; // how long the visual will run if not crashed (ms). We'll speed up multiplier.

      tickInterval = setInterval(()=>{
        // increase multiplier: exponential-ish
        const elapsed = Date.now() - start;
        // base growth curve
        multiplier = 1 + (Math.exp(elapsed/1200) - 1) * 0.12; // tuned for nice curve
        if(multiplier>100) multiplier = multiplier; // cap visually
        multEl.textContent = multiplier.toFixed(2) + '×';
        const progressPct = Math.min(100, (Math.log(multiplier+1)/Math.log(100+1)) * 100);
        progressEl.style.width = progressPct + '%';
        drawChartAddPoint(multiplier);

        // check auto cashout
        if(placedBet && autoVal>0 && multiplier>=autoVal){
          // auto cash out
          const win = placedBet.amount * autoVal;
          balance += win;
          addHistory({result:'AUTO CASHOUT', details:`WON ${win.toFixed(2)} coins @ ${autoVal.toFixed(2)}×`, mult:autoVal, time: new Date().toLocaleTimeString()});
          endRound(true);
        }

        // check crash
        if(multiplier >= crashPoint){
          // crash now
          addHistory({result:'CRASHED', details:`CRASHED @ ${crashPoint.toFixed(2)}×`, mult:crashPoint, time: new Date().toLocaleTimeString()});
          endRound(false);
        }

        renderBalance();
      }, 80);
    }

    function generateCrashPoint(){
      // simple random crash distribution for demo only.
      // produces values >=1.0, with many near small multipliers and occasional big ones
      const r = Math.random();
      // heavy-tail: transform r
      const crash = Math.max(1 + Math.floor(Math.pow(1/(1-r), 1.2) * 100)/100, 1.0);
      // cap to avoid infinity
      return Math.min(crash, 500);
    }

    // ----------------- Chart drawing -----------------
    let chartData = [];
    function drawChartClear(){
      chartData = [];
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
    }
    function drawChartAddPoint(val){
      chartData.push(val);
      if(chartData.length>200) chartData.shift();
      // draw
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // background grid
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      const w = canvas.width; const h = canvas.height;
      // y scale: log scale for visibility
      const maxV = Math.max(5, ...chartData);
      ctx.beginPath();
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(255,181,86,0.9)';
      for(let i=0;i<chartData.length;i++){
        const x = (i/(200-1))*w;
        const y = h - (Math.log(chartData[i]+1)/Math.log(maxV+1))*h;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }

    drawChartClear();

    // simple safety: prevent negative balance
    setInterval(()=>{ if(balance<0) balance=0; renderBalance(); }, 1000);

  </script></body>
</html>
